ad_library {
    Establishing site-wide style conventions and supporting documentation.
    
    @author Phillip Greenspun [philg@arsdigita.colm]
    @creation-date June 30, 1999
    @cvs-id ad-style.tcl,v 3.7.2.5 2000/09/22 01:33:58 kevin Exp
}

proc_doc ad_register_styletag {tagname tag_documentation proc_body} {Defines a new site-wide style, includes an ADP tag and a procedure for use by .tcl pages (starting with "ad_style_").  The supplied procedure body should reference $string and $tagset (the variables given in the AOLserver Tcl API docs for ns_register_adptag)} {
    ns_share ad_styletag
    ns_share ad_styletag_source_file
    set generated_proc_name "ad_style_$tagname"
    proc_doc $generated_proc_name  {{string ""} {tagset ""}} "Proc generated by ad_register_styletag to support the $tagname ADP tag." $proc_body
    # let's register the ADP tag now
    ns_register_adptag $tagname "/$tagname" $generated_proc_name
    set ad_styletag($tagname) $tag_documentation
    set ad_styletag_source_file($tagname) [info script]
}

proc ad_style_template_root_internal {} {
    if ![empty_string_p [ad_parameter TemplateRoot "style"]] {
	return [ad_parameter TemplateRoot "style"]
    }
    # we have to regsub to turn /web/yourservername/www into 
    # /web/yourservername/templates
    set page_root [ns_info pageroot]
    regsub {/www$} $page_root {/templates} template_root
    return $template_root
}

proc ad_style_template_root {} {
    return [util_memoize "ad_style_template_root_internal"]
}

# per /doc/style.html we standardize on "language_preference"
# and "prefer_text_only_p" as the names of the cookies
proc ad_style_language_from_cookie {} {
    set headers [ns_conn headers]
    set cookie [ns_set get $headers Cookie]
    if { [regexp {language_preference=([^;]+)} $cookie {} language_preference] } {
	return $language_preference
    } else {
	return ""
    }
}

proc ad_style_plain_fancy_from_cookie {} {
    set headers [ns_conn headers]
    set cookie [ns_set get $headers Cookie]
    if { [regexp {prefer_text_only_p=([^;]+)} $cookie {} prefer_text_only_p] } {
	if { $prefer_text_only_p == "t" } {
	    return "plain"
	} else {
	    return "fancy"
	}
	return $language_preference
    } else {
	return ""
    }
}

proc_doc ad_style_user_preferences_from_db {user_id} "Returns a list of prefer_text_only_p and language_preference from the users_preferences table; probably you should call this within a util_memoize so that you aren't kicking the stuffing out of Oracle." {
    if { [db_0or1row preference_select {
	select prefer_text_only_p, language_preference 
	from users_preferences 
	where user_id = :user_id
    }] } {
	set result_list [list $prefer_text_only_p $language_preference]
    } else {
	set result_list [list "" ""]
    }
    return $result_list 
}

# takes list of raw filenames and returns a list of lists
# (each sublist is score then filename)
# we give a template scores as follows:
#   2000 for having the user's preferred language
#   1000 for having the site's default language
#    200 for having the user's default plain/fanciness
#    100 for having the site's default plain/fanciness
# subtract the length of the filename so that shorter ones have precedence
# (note that language outweighs graphical fanciness)
proc ad_style_score_templates {template_filename_list} {
    # set defaults
    set user_preferred_language ""
    set user_preferred_plain_fancy ""
    set site_default_language [ad_parameter LanguageSiteDefault style]
    set site_default_plain_fancy [ad_parameter PlainFancySiteDefault style]
    # let's figure out first whether or not this is a logged-in person
    set user_id [ad_get_user_id]
    if { $user_id == 0 } {
	# not logged in, maybe cookied though
	if [ad_parameter LanguageCookieP style] {
	    # let's at least look for a cookie
	    set user_preferred_language [ad_style_language_from_cookie]
	}
	if [ad_parameter PlainFancyCookieP style] {
	    set user_preferred_plain_fancy [ad_style_plain_fancy_from_cookie]
	}
    } else {
	# this is a logged-in user, let's get this info from users_preferences
	set preferences_list [util_memoize "ad_style_user_preferences_from_db $user_id" 900]
	set prefer_text_only_p [lindex $preferences_list 0]
	set language_preference [lindex $preferences_list 1]
	# if the text_only_p column isn't null, set user preference
	if { $prefer_text_only_p == "t" } {
	    set user_preferred_plain_fancy "plain"
	} elseif { $prefer_text_only_p == "f" } {
	    set user_preferred_plain_fancy "fancy"
	} 
	set user_preferred_language $language_preference
    }
    set result_list [list]
    foreach filename $template_filename_list {
	set score 0
	if { ![empty_string_p $user_preferred_language] && [string match "*.$user_preferred_language.*" $filename] } {
	    incr score 2000
	}
	if { ![empty_string_p $site_default_language] && [string match "*.$site_default_language.*" $filename] } {
	    incr score 1000
	}
	if { ![empty_string_p $user_preferred_plain_fancy] && [string match "*.$user_preferred_plain_fancy.*" $filename] } {
	    incr score 200
	}
	if { ![empty_string_p $site_default_plain_fancy] && [string match "*.$site_default_plain_fancy.*" $filename] } {
	    incr score 100
	}
	set score [expr $score - [string length $filename]]
	lappend result_list [list $score $filename]
    }
    return $result_list
}

proc ad_style_sort_by_score {l1 l2} {
    if { [lindex $l1 0] < [lindex $l2 0] } {
	return -1 
    } elseif { [lindex $l1 0] == [lindex $l2 0] } {
	return 0
    } else {
	return 1
    }
}

proc_doc ad_return_template { { file_name "" } { cache_p 1 } } { Finds a template to source (looks at what templates are available, what the user prefers, and what the site defaults are), parses it in the caller's environment, and ns_return's the bytes to the user. file_name, if specified, overrides the base file name used to determine which template to use. cache_p, if specified, can disable or enable caching by altering the HTTP header.} {
    set full_url [ns_conn url]

    if { [string index $full_url [expr [string length $full_url]-1]] == "/" } {
	append full_url "index.tcl"
    }

    set just_the_dir [file dirname $full_url]
    
    if [empty_string_p $file_name] {
	set file_name [file rootname [file tail $full_url]]
    }
    set template_directory "[ad_style_template_root]$just_the_dir"
    set glob_pattern "${template_directory}/${file_name}*.adp"
    set available_templates [glob -nocomplain $glob_pattern]

    if { [llength $available_templates] == 0 } {
	ad_return_error "No template available" "We can't find any template for presenting the output of this script.  Sorry but you're a victim of our graphics ambition.  Please complain to the site owner."
    } else {
	# we have at least one template available; we need to score
	# them against user's criteria, then pick the highest scorer
	set list_of_lists [ad_style_score_templates $available_templates]
	set sorted_list [lsort -decreasing -command ad_style_sort_by_score $list_of_lists]
	set top_scoring_template_filename [lindex [lindex $sorted_list 0] 1]
	set fully_qualified_template_filename "$top_scoring_template_filename"

	if { $cache_p } {
	    # build the http header, with a no cache pragma if cache_p is 0
	    set http_header "HTTP/1.0 200 OK
MIME-Version: 1.0
Content-Type: text/html
Pragma: No-Cache

"
	    ns_write $http_header
	    ns_startcontent -type text/html
	    eval "uplevel { ns_write \"\[ns_adp_parse -file \"$fully_qualified_template_filename\"\]\" }"
	} else {
	    eval "uplevel { doc_return  200 text/html \[ns_adp_parse -file \"$fully_qualified_template_filename\"\] }"
	}
    }
}

# sample style tag
# You will get an error if you try to register
# a style tag more than once.  

ad_register_styletag footer "Standard ArsDigita footer." {
    global sidegraphic_displayed_p
    set signatory $string
    if [empty_string_p $signatory] {
	set signatory [ad_system_owner]
    } 
    if { [info exists sidegraphic_displayed_p] && $sidegraphic_displayed_p } {
	# we put in a BR CLEAR=RIGHT so that the signature will clear any side graphic
	# from the ad-sidegraphic.tcl package
	set extra_br "<br clear=right>"
    } else {
	set extra_br ""
    }
    return "
$extra_br
<hr>
<a href=\"mailto:$signatory\"><address>$signatory</address></a>
"
}

# the following style will be available in ADP pages as <BODYNOTE>
# and in Tcl pages as [ad_style_bodynote "what you want to note"]
#
# RDH: moved from photonet-styles.tcl (2000-05-30)

ad_register_styletag bodynote "A note that goes inline on a page; generally presented smaller and in a sans serif font." {
    return "<blockquote>
<font size=-2 face=\"verdana, arial, helvetica\">
$string
</font>
</blockquote>
"
}

